/* Даны указатели P1 и P2 на начало и конец непустой очереди. Извлекать из очереди
элементы, пока значение начального элемента очереди не станет четным, и выводить значения
извлеченных элементов(если очередь не содержит элементов с четными значениями, то извлечь
все ее элементы).Вывести также новые адреса начала и конца очереди(для пустой очереди
дважды вывести nullptr).После извлечения элементов из очереди освобождать память, которую
они занимали.


Для каждой динамической структуры должен быть предусмотрен стандартный набор методов -
добавления/удаления/вывода элементов.
Во всех задачах обязательно наличие дружественного интерфейса. Ввод данных с клавиатуры.


В заданиях данной подгруппы структура «очередь» (queue) моделируется цепочкой связанных
узлов-записей типа TNode. Поле Next последнего элемента цепочки равно nullptr. Началом
очереди («головой», head) считается первый элемент цепочки, концом («хвостом», tail) — ее
последний элемент. Для возможности быстрого добавления в конец очереди нового элемента
удобно хранить, помимо указателя на начало очереди, также и указатель на ее конец. В случае
пустой очереди указатели на ее начало и конец полагаются равными nullptr. Как и для стека,
значением элемента очереди считается значение его поля Data.*/
#include "queue.h"
#include <iostream>
#include <string>

using namespace std;

int getValidNumber(const string& prompt) {
    string input;
    while (true) {
        cout << prompt;
        cin >> input;

        if (isNumber(input)) {
            return stoi(input);
        }

        cout << "Ошибка: введите целое число!\n";
        cin.clear();
    }
}

int main() {
    Queue queue;

    // Ввод количества элементов
    int count = getValidNumber("Введите количество элементов в очереди: ");

    // Ввод элементов очереди
    for (int i = 0; i < count; ++i) {
        int num = getValidNumber("Введите элемент " + to_string(i + 1) + ": ");
        queue.enqueue(num);
    }

    // Вывод исходной очереди
    cout << "\nИзначальная очередь: " << queue.toString() << endl;

    // Извлечение элементов до первого четного
    string extracted = queue.extractUntilEven();
    cout << "Извлеченные элементы: " << (extracted.empty() ? "нет" : extracted) << endl;

    // Вывод измененной очереди
    cout << "Измененная очередь: " << queue.toString() << endl;

    // Вывод информации о первом элементе
    int headValue;
    if (queue.getHeadData(headValue)) {
        cout << "Значение первого элемента: " << headValue << endl;
    }
    else {
        cout << "Очередь пуста, первого элемента нет" << endl;
    }

    // Вывод адреса начала очереди
    cout << "Адрес начала очереди (P1): " << queue.getHead() << endl;

    // Вывод информации о последнем элементе
    int tailValue;
    if (queue.getTailData(tailValue)) {
        cout << "Значение последнего элемента: " << tailValue << endl;
    }
    else {
        cout << "Очередь пуста, последнего элемента нет" << endl;
    }

    // Вывод адреса конца очереди
    cout << "Адрес конца очереди (P2): " << queue.getTail() << endl;

    return 0;
}
